N int

source int

edges int[N][N]

{Format  csr({Dense,Sparse});
Tensor<int> edges("edges", {N, N}, csr);}

Let BFS_Step(F_in int[N], P_in int[N], V_in int[N]) -> (F_out int[N], P_out int[N], V_out int[N])
    V_out[j] = P_in[j] == 0 - 1
    F_out[j] = edges[j][k] * F_in[k] * V_out[j] | k: (OR, 0)
    P_out[j] = edges[j][k] * F_in[k] * V_out[j] * (k + 1) | k:(CHOOSE, P_in[j])
End

Let Init() -> (F int[N], P int[N])
    F[j] = (j == source)
    {Tensor<int> F("F", {N}, Format({Sparse}));
     F.insert({source}, 1);

     OR

     IndexVar j;
     F[j] = (j == source);
     F.evaluate();
    }
    P[j] = (j == source) * (0 - 2) + (j != source) * (0 - 1)
    {
    Tensor<int> P("P", {N}, Format({Sparse}));
    IndexVar j;
    P[j] = (j == source) * (0 - 2) + (j != source) * (0 - 1);
    P.evaluate();
    }
    {return std::tuple<Tensor<int>, Tensor<int>>(F, P);}
End

Let BFS() -> (P_out int[N], F_in int[N], P_in int[N], V int[N])
    F_in, P_in = Init()
    V[i] = 0
    _, P_out, _ = BFS_Step*(F_in, P_in, V) | (#1 == 0)
    {
    out1, out2, out3 = BFS_Step(F_in, P_in, V);
    while (out1 != 0) {
        out1, out2, out3 = BFS_Step(out1, out2, out3);
    }
    }
End
